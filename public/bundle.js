var app = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) { tar[k] = src[k]; }
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) { tar[k] = 1; }
		return tar;
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) { iterations[i].d(detach); }
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var this$1 = this;

		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) { return; }

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this$1, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) { handlers.splice(index, 1); }
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) { return; }
		flush(this.root);
	}

	function _set(newState) {
		var this$1 = this;

		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this$1._differs(newState[key], oldState[key])) { changed[key] = dirty = true; }
		}
		if (!dirty) { return; }

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) { this._bind(changed, this._state); }

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) { fns.shift()(); }
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy: destroy,
		get: get,
		fire: fire,
		on: on,
		set: set,
		_recompute: noop,
		_set: _set,
		_stage: _stage,
		_mount: _mount,
		_differs: _differs
	};

	/* src\Map.html generated by Svelte v2.13.5 */

	var serverBase = window.serverBase || '//maps.kosmosnimki.ru/';
	var apikey = 'PBZU2XXPDM';
	var sectionsLen = 10;
	var questionLen = 10;
	var gameZoom = 3;
	var  pars = (function () {
		var  p = {};
		location.search.substr(1).split('&').forEach(function (it) {
			var  arr = it.split('=');
			p[arr[0]] = arr[1];
		});
		return p;
	})();

	function data() {
		return {
			quizList: null,
			sectionsList: null,
			questions: null,
			permalink: null,
			map: null
		}
	}
	var methods = {
		getSections: function getSections(arr) {
			var sections = {},
				sectionsFlags = {};
			arr.forEach(function(it) {
				var key = it.properties.SECTION;
				if (!sections[key]) { sections[key] = []; }			sections[key].push(it);
			});
			var arrSections = Object.keys(sections).sort(function () { return Math.random() > 0.5; } ),
				len = arrSections.length,
				sections1 = {};
			// console.log('llll', arrSections);
			for(var i = 0, len1 = len > sectionsLen ? sectionsLen : len; i < len1; i++) {
				var key = arrSections[i];
				sections1[key] = sections[key];
				sectionsFlags[key] = true;
			}
			this.set({sectionsList: sections1, sectionsFlags: sectionsFlags});
		},
		reBuildQuestions: function reBuildQuestions(sectionsList) {
			var arr = [],
				sectionsKeyArr = Object.keys(sectionsList),
				sectionsLen = sectionsKeyArr.length;
			for(var i = 0; i < questionLen; i++) {
				var key = sectionsKeyArr[Math.floor(sectionsLen * Math.random())],
					arr1 = sectionsList[key],
					len1 = arr1.length;
				arr.push(arr1[Math.floor(len1 * Math.random())]);
			}
			this.set({questions: arr, reBuildQuestions: false});
		},
		getQuestion: function getQuestion(question) {
			var ref = this.get();
			var layerID = ref.layerID;

			this.question = null;
			var query = 'gmx_id=' + question.properties.gmx_id,
				url = serverBase + 'rest/ver1/layers/' + layerID + '/search?sw=1&apikey=' + apikey + '&query=' + query;
			fetch(url, {mode: 'cors', credentials: 'include'})
				.then(function(resp) { return resp.json(); })
				.then(function(json) {
					this.question = json.features[0];
					if (this.needResult) {
						this.showQuestionResult();
						this.needResult = false;
					}
				}.bind(this));

			this._clearLayers();
			this.map.setZoom(gameZoom);
		},
		getLayerGame: function getLayerGame(layerID) {
			var url = serverBase + 'rest/ver1/layers/' + layerID + '/search?apikey=' + apikey + '&columns=[{%22Value%22:%22[gmx_id]%22},{%22Value%22:%22[TITLE]%22},{%22Value%22:%22SECTION%22}]';
			fetch(url, {mode: 'cors', credentials: 'include'})
				.then(function(resp) { return resp.json(); })
				.then(function(json) {
					this.allData = json.features;
					this.getSections(this.allData);
				}.bind(this));
		},
		showQuestionResult: function showQuestionResult() {
			// if (this.polyline) { this.map.removeLayer(this.polyline); }
			var ref = this.get();
			var emotions = ref.emotions;
			var item = this.question,
				layers = L.geoJSON(item.geometry).getLayers(),
				closestLayer = L.GeometryUtil.closestLayer(this.map, layers, this._latlng),
				closest = L.GeometryUtil.closest(this.map, closestLayer.layer, this._latlng, false),

				currentLayer = closestLayer.layer,
				bounds = currentLayer.getBounds(),
				isContains = bounds.contains(this._latlng),
				
				polyline = L.geodesic([[closest, this._latlng]], {color: 'red'}).addTo(this.map);

			this.map.fitBounds(polyline.getBounds());
			var geoJson = polyline.toGeoJSON().geometry;

			this.currentLayer = currentLayer.addTo(this.map);
			this.polyline = polyline;
			var lenM = L.gmxUtil.geoJSONGetLength(geoJson),
				lenKm = Math.round(lenM / 1000),
				strLen = L.gmxUtil.getGeoJSONSummary(geoJson),
				resultQuestion = {},
				// sc = 0,
				emotion;
			for (var i = 0, c, p, len = emotions.emotion.length; i < len; i++) {
				c = emotions.emotion[i];
				if (c.error > lenKm || i === len - 1) {
					var it = i === len - 1 ? c : p || c;
					emotion = {title: emotions.rank[it.rank], color: it.color, score: strLen};
					break;
				}
				p = c;
			}
			
			if (isContains) {
				// sc = 10;
				emotion = {title: 'ВАУ, КРУТО!', score: ''};
				// resultQuestion.ok = sc + ' баллов';
				if (this.audioStarted) { this.audio.stop(0); }
				this.audioStart(11.74689342403628, 3.82984126984127);
			} else {
				this.audioStart(8.50453514739229, 0.20950113378684806);
				
			}
			resultQuestion.question = item;
			resultQuestion.len = isContains ? 0 : lenM;
			resultQuestion.strLen = isContains ? '0' : strLen;
			this.set({resultQuestion: resultQuestion, emotion: emotion});
		},
		clickMap: function clickMap(ev) {
			if (this.marker) {
				this.map.removeLayer(this.marker);
			}
			this._latlng = ev.latlng;
			this.marker = L.marker(this._latlng, {icon: L.divIcon({className: 'my-div-icon', iconSize: [4, 4], iconAnchor:[10, 10]})}).addTo(this.map);
			
			this.set({point: true});
		},
		audioStart: function audioStart(start, duration) {
			if (this.sound) {
				fetch('mp3/audio.mp3', { mode: 'cors', credentials: 'include' })
					.then(function (response) { return response.arrayBuffer(); })
					.then(function(buf) {
						var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
						audioCtx.decodeAudioData(buf, function(buffer) {
							var source = audioCtx.createBufferSource();
							source.buffer = buffer;
							source.start(audioCtx.currentTime + 1, start, duration);
							source.connect(audioCtx.destination);
							// source.loop = true;
						  },
						  function(e){ console.log("Error with decoding audio data" + e.err); }
						);
					}.bind(this));
			}
		},
		_clearLayers: function _clearLayers() {
			if (this.marker) { this.map.removeLayer(this.marker); this.marker = null; }
			if (this.polyline) { this.map.removeLayer(this.polyline); this.polyline = null; }
			if (this.currentLayer) { this.map.removeLayer(this.currentLayer); this.currentLayer = null; }
		},
		createMap: function createMap() {
			var it = pars,
				state = it.state || {},
				layerID = it.layerID || 'F9728D94848F4163A19DF5B5A6BFDDF1', //'5F2A707A119A45EF9BD490187E909830',
				apiKey = it.apiKey || apikey,
				pos = state.map ? state.map.position : {};

			this.sound = it.sound && (window.AudioContext || window.webkitAudioContext);

			var osm = it.base == 1 ? 
				L.tileLayer('//tilessputnik.ru/{z}/{x}/{y}.png', {
	                        attribution: '<a href="http://maps.sputnik.ru">Спутник</a> © Ростелеком | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
					maxNativeZoom: 18,
					maxZoom: 21
				}) :
				L.tileLayer('//maps.kosmosnimki.ru/TileSender.ashx?sw=1&ModeKey=tile&ftc=osm&srs=3857&z={z}&x={x}&y={y}&LayerName=C9458F2DCB754CEEACC54216C7D1EB0A&apiKey=' + apiKey, {
					maxNativeZoom: 18,
					maxZoom: 21
				});
				// L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1Ijoia29zbW9zbmlta2kiLCJhIjoiY2lvbW1tNXN0MDAwdnc4bHg5ZWw2YXJtYSJ9.ON9Ovi3fuHc5RAipmLb2EQ', {
					// attribution: '&copy; <a href="//mapbox.com/">mapbox</a>',
					// maxNativeZoom: 18,
					// maxZoom: 21
				// });

			var map = new L.Map('map', {
				attribution: '&copy; <a href="//scanex.ru/">scanex</a>',
				allWorld: true,
				generalized: false,
				layers: [osm],
				center: new L.LatLng(pos.y || 26, pos.x || 83),
				zoom: pos.z || 7
			}).on('click', this.clickMap.bind(this), this);

			// map.gmxControlsManager.init();
			map.zoomControl.setPosition('bottomright');
			if (layerID) {
				this.getLayerGame(layerID);
			}
			this.quizList = true;
			this.map = map;
		}
	};

	function oncreate() {
		var ref = this.get();
		var urlParams = ref.urlParams;
		this.createMap(urlParams);
	}
	function onstate(ref) {
		var changed = ref.changed;
		var current = ref.current;
		var previous = ref.previous;

		console.log('in onstate', changed, current, previous);
		if (changed.selectQuiz && current.selectQuiz) {
			this._clearLayers();
			this.set({quizList: this.quizList});
		} else if (changed.layerID && current.layerID) {
			this.getSections(this.allData);
		} else if (changed.question && current.question) {
			this.getQuestion(current.question);
		} else if (current.reBuildQuestions) {
			this.reBuildQuestions(current.sectionsList);
		} else if (changed.calc && current.calc) {
			if (this.question) {
				this.showQuestionResult();
			} else {
				this.needResult = true;
			}
		}
	}
	function create_main_fragment(component, ctx) {
		var div, current;

		return {
			c: function c() {
				div = createElement("div");
				div.id = "map";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				current = true;
			},

			p: noop,

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: run,

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function Map(options) {
		var this$1 = this;

		init(this, options);
		this._state = assign(data(), options.data);
		this._intro = !!options.intro;

		this._handlers.state = [onstate];

		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(function () {
			oncreate.call(this$1);
			this$1.fire("update", { changed: assignTrue({}, this$1._state), current: this$1._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Map.prototype, proto);
	assign(Map.prototype, methods);

	/* src\App.html generated by Svelte v2.13.5 */

	function currentItog(ref) {
		var currentScore = ref.currentScore;

		return L.gmxUtil.prettifyDistance(currentScore.reduce(function (p, c) { return p + c.len; }, 0));
	}

	function isSectionsEmpty(ref) {
		var sectionsList = ref.sectionsList;

		return !(sectionsList && Object.keys(sectionsList).length);
	}

	function data$1() {
		return {
			quizList: [],
			layerGame: null,
			selectQuiz: null,
			sectionsList: {},
			sectionsFlags: {},
			layerID: '',
			questions: false,
			question: false,
			point: false,
			calc: false,
			emotion: false,
			emotions: emotions,
			resultQuestion: false,
			reBuildQuestions: false,
			currentScore: [],
			score: null
		}
	}
	var methods$1 = {
		checkSection: function checkSection(key, flag) {
			console.log('checkSection', key, flag);
			var ref = this.get();
			var sectionsList = ref.sectionsList;
			var sectionsFlags = ref.sectionsFlags;
			sectionsFlags[key] = flag;
			this.set({sectionsFlags: sectionsFlags});
		},
		start: function start() {
		console.log('start');
			this.set({reBuildQuestions: true, quizList: null, layerID: 'F9728D94848F4163A19DF5B5A6BFDDF1'});
			this.nextQuestion(0, true);
		},
		nextQuestion: function nextQuestion(sc, clearCurrentScore) {
			var ref = this.get();
			var questions = ref.questions;
			var props = ref.props;
			var score = ref.score;
			var currentScore = ref.currentScore;
			var question = questions.shift();

			if (clearCurrentScore) { currentScore = []; }
			this.set({questions: questions, question: question, point: false, calc: false, resultQuestion: false, currentScore: currentScore});
		}
	};

	function onstate$1(ref) {
		var changed = ref.changed;
		var current = ref.current;
		var previous = ref.previous;

		console.log('in app onstate', changed, current, previous);
		if (changed.resultQuestion && current.resultQuestion) {
			var ref$1 = this.get();
			var currentScore = ref$1.currentScore;
			currentScore.push(current.resultQuestion);
			this.set({currentScore: currentScore});
		}
	}
	function create_main_fragment$1(component, ctx) {
		var map_updating = {}, text, text_1, div, div_1, text_3, div_2, current;

		var map_initial_data = {};
		if (ctx.selectQuiz
		 !== void 0) {
			map_initial_data.selectQuiz = ctx.selectQuiz
		;
			map_updating.selectQuiz = true;
		}
		if (ctx.sectionsList
		 !== void 0) {
			map_initial_data.sectionsList = ctx.sectionsList
		;
			map_updating.sectionsList = true;
		}
		if (ctx.sectionsFlags
		 !== void 0) {
			map_initial_data.sectionsFlags = ctx.sectionsFlags
		;
			map_updating.sectionsFlags = true;
		}
		if (ctx.quizList
		 !== void 0) {
			map_initial_data.quizList = ctx.quizList
		;
			map_updating.quizList = true;
		}
		if (ctx.layerID
		 !== void 0) {
			map_initial_data.layerID = ctx.layerID
		;
			map_updating.layerID = true;
		}
		if (ctx.layerGame
		 !== void 0) {
			map_initial_data.layerGame = ctx.layerGame
		;
			map_updating.layerGame = true;
		}
		if (ctx.score
		 !== void 0) {
			map_initial_data.score = ctx.score
		;
			map_updating.score = true;
		}
		if (ctx.questions
		 !== void 0) {
			map_initial_data.questions = ctx.questions
		;
			map_updating.questions = true;
		}
		if (ctx.question
		 !== void 0) {
			map_initial_data.question = ctx.question
		;
			map_updating.question = true;
		}
		if (ctx.point
		 !== void 0) {
			map_initial_data.point = ctx.point
		;
			map_updating.point = true;
		}
		if (ctx.calc
		 !== void 0) {
			map_initial_data.calc = ctx.calc
		;
			map_updating.calc = true;
		}
		if (ctx.emotion
		 !== void 0) {
			map_initial_data.emotion = ctx.emotion
		;
			map_updating.emotion = true;
		}
		if (ctx.emotions
		 !== void 0) {
			map_initial_data.emotions = ctx.emotions
		;
			map_updating.emotions = true;
		}
		if (ctx.resultQuestion
		 !== void 0) {
			map_initial_data.resultQuestion = ctx.resultQuestion
		;
			map_updating.resultQuestion = true;
		}
		if (ctx.reBuildQuestions
	 !== void 0) {
			map_initial_data.reBuildQuestions = ctx.reBuildQuestions
	;
			map_updating.reBuildQuestions = true;
		}
		var map = new Map({
			root: component.root,
			store: component.store,
			data: map_initial_data,
			_bind: function _bind(changed, childState) {
				var newState = {};
				if (!map_updating.selectQuiz && changed.selectQuiz) {
					newState.selectQuiz = childState.selectQuiz;
				}

				if (!map_updating.sectionsList && changed.sectionsList) {
					newState.sectionsList = childState.sectionsList;
				}

				if (!map_updating.sectionsFlags && changed.sectionsFlags) {
					newState.sectionsFlags = childState.sectionsFlags;
				}

				if (!map_updating.quizList && changed.quizList) {
					newState.quizList = childState.quizList;
				}

				if (!map_updating.layerID && changed.layerID) {
					newState.layerID = childState.layerID;
				}

				if (!map_updating.layerGame && changed.layerGame) {
					newState.layerGame = childState.layerGame;
				}

				if (!map_updating.score && changed.score) {
					newState.score = childState.score;
				}

				if (!map_updating.questions && changed.questions) {
					newState.questions = childState.questions;
				}

				if (!map_updating.question && changed.question) {
					newState.question = childState.question;
				}

				if (!map_updating.point && changed.point) {
					newState.point = childState.point;
				}

				if (!map_updating.calc && changed.calc) {
					newState.calc = childState.calc;
				}

				if (!map_updating.emotion && changed.emotion) {
					newState.emotion = childState.emotion;
				}

				if (!map_updating.emotions && changed.emotions) {
					newState.emotions = childState.emotions;
				}

				if (!map_updating.resultQuestion && changed.resultQuestion) {
					newState.resultQuestion = childState.resultQuestion;
				}

				if (!map_updating.reBuildQuestions && changed.reBuildQuestions) {
					newState.reBuildQuestions = childState.reBuildQuestions;
				}
				component._set(newState);
				map_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			map._bind({ selectQuiz: 1, sectionsList: 1, sectionsFlags: 1, quizList: 1, layerID: 1, layerGame: 1, score: 1, questions: 1, question: 1, point: 1, calc: 1, emotion: 1, emotions: 1, resultQuestion: 1, reBuildQuestions: 1 }, map.get());
		});

		var if_block = (!ctx.question) && create_if_block(component, ctx);

		var if_block_1 = (ctx.question) && create_if_block_1(component, ctx);

		function select_block_type_3(ctx) {
			if (ctx.quizList) { return create_if_block_2; }
			if (ctx.question) { return create_if_block_4; }
			if (!ctx.layerID) { return create_if_block_10; }
			return create_if_block_11;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block_2 = current_block_type(component, ctx);

		return {
			c: function c() {
				map._fragment.c();
				text = createText("\r\n");
				if (if_block) { if_block.c(); }
				text_1 = createText("\r\n");
				div = createElement("div");
				div_1 = createElement("div");
				if (if_block_1) { if_block_1.c(); }
				text_3 = createText("\r\n\t");
				div_2 = createElement("div");
				if_block_2.c();
				div_1.className = "title bg svelte-yzh5fj";
				div_2.className = "content svelte-yzh5fj";
				div.className = "controls svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				map._mount(target, anchor);
				insert(target, text, anchor);
				if (if_block) { if_block.m(target, anchor); }
				insert(target, text_1, anchor);
				insert(target, div, anchor);
				append(div, div_1);
				if (if_block_1) { if_block_1.m(div_1, null); }
				append(div, text_3);
				append(div, div_2);
				if_block_2.m(div_2, null);
				current = true;
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				var map_changes = {};
				if (!map_updating.selectQuiz && changed.selectQuiz) {
					map_changes.selectQuiz = ctx.selectQuiz
		;
					map_updating.selectQuiz = ctx.selectQuiz
		 !== void 0;
				}
				if (!map_updating.sectionsList && changed.sectionsList) {
					map_changes.sectionsList = ctx.sectionsList
		;
					map_updating.sectionsList = ctx.sectionsList
		 !== void 0;
				}
				if (!map_updating.sectionsFlags && changed.sectionsFlags) {
					map_changes.sectionsFlags = ctx.sectionsFlags
		;
					map_updating.sectionsFlags = ctx.sectionsFlags
		 !== void 0;
				}
				if (!map_updating.quizList && changed.quizList) {
					map_changes.quizList = ctx.quizList
		;
					map_updating.quizList = ctx.quizList
		 !== void 0;
				}
				if (!map_updating.layerID && changed.layerID) {
					map_changes.layerID = ctx.layerID
		;
					map_updating.layerID = ctx.layerID
		 !== void 0;
				}
				if (!map_updating.layerGame && changed.layerGame) {
					map_changes.layerGame = ctx.layerGame
		;
					map_updating.layerGame = ctx.layerGame
		 !== void 0;
				}
				if (!map_updating.score && changed.score) {
					map_changes.score = ctx.score
		;
					map_updating.score = ctx.score
		 !== void 0;
				}
				if (!map_updating.questions && changed.questions) {
					map_changes.questions = ctx.questions
		;
					map_updating.questions = ctx.questions
		 !== void 0;
				}
				if (!map_updating.question && changed.question) {
					map_changes.question = ctx.question
		;
					map_updating.question = ctx.question
		 !== void 0;
				}
				if (!map_updating.point && changed.point) {
					map_changes.point = ctx.point
		;
					map_updating.point = ctx.point
		 !== void 0;
				}
				if (!map_updating.calc && changed.calc) {
					map_changes.calc = ctx.calc
		;
					map_updating.calc = ctx.calc
		 !== void 0;
				}
				if (!map_updating.emotion && changed.emotion) {
					map_changes.emotion = ctx.emotion
		;
					map_updating.emotion = ctx.emotion
		 !== void 0;
				}
				if (!map_updating.emotions && changed.emotions) {
					map_changes.emotions = ctx.emotions
		;
					map_updating.emotions = ctx.emotions
		 !== void 0;
				}
				if (!map_updating.resultQuestion && changed.resultQuestion) {
					map_changes.resultQuestion = ctx.resultQuestion
		;
					map_updating.resultQuestion = ctx.resultQuestion
		 !== void 0;
				}
				if (!map_updating.reBuildQuestions && changed.reBuildQuestions) {
					map_changes.reBuildQuestions = ctx.reBuildQuestions
	;
					map_updating.reBuildQuestions = ctx.reBuildQuestions
	 !== void 0;
				}
				map._set(map_changes);
				map_updating = {};

				if (!ctx.question) {
					if (!if_block) {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(text_1.parentNode, text_1);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (ctx.question) {
					if (if_block_1) {
						if_block_1.p(changed, ctx);
					} else {
						if_block_1 = create_if_block_1(component, ctx);
						if_block_1.c();
						if_block_1.m(div_1, null);
					}
				} else if (if_block_1) {
					if_block_1.d(1);
					if_block_1 = null;
				}

				if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block_2) {
					if_block_2.p(changed, ctx);
				} else {
					if_block_2.d(1);
					if_block_2 = current_block_type(component, ctx);
					if_block_2.c();
					if_block_2.m(div_2, null);
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (map) { map._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				map.destroy(detach);
				if (detach) {
					detachNode(text);
				}

				if (if_block) { if_block.d(detach); }
				if (detach) {
					detachNode(text_1);
					detachNode(div);
				}

				if (if_block_1) { if_block_1.d(); }
				if_block_2.d();
			}
		};
	}

	// (18:0) {#if !question}
	function create_if_block(component, ctx) {
		var div;

		return {
			c: function c() {
				div = createElement("div");
				div.className = "scrim svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (23:1) {#if question}
	function create_if_block_1(component, ctx) {
		var button;

		function click_handler(event) {
			component.set({question:''});
		}

		return {
			c: function c() {
				button = createElement("button");
				button.textContent = "Начать игру заново";
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
			},

			m: function m(target, anchor) {
				insert(target, button, anchor);
			},

			p: function p(changed, ctx) {
				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (33:2) {#if !isSectionsEmpty}
	function create_if_block_3(component, ctx) {
		var button;

		function click_handler(event) {
			component.set({quizList: null, layerID: 'F9728D94848F4163A19DF5B5A6BFDDF1'});
		}

		return {
			c: function c() {
				button = createElement("button");
				button.textContent = "Давайте проверим!";
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
			},

			m: function m(target, anchor) {
				insert(target, button, anchor);
			},

			p: function p(changed, ctx) {
				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (44:4) {#if questions && questions.length}
	function create_if_block_6(component, ctx) {
		var button;

		function click_handler(event) {
			component.nextQuestion();
		}

		return {
			c: function c() {
				button = createElement("button");
				button.textContent = "Следующий вопрос";
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, button, anchor);
			},

			p: noop,

			d: function d(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (46:4) {:else}
	function create_if_block_7(component, ctx) {
		var div, text, span, text_1;

		return {
			c: function c() {
				div = createElement("div");
				text = createText("Ваш итоговый результат: ");
				span = createElement("span");
				text_1 = createText(ctx.currentItog);
				span.className = "red svelte-yzh5fj";
				div.className = "itog";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				append(div, span);
				append(span, text_1);
			},

			p: function p(changed, ctx) {
				if (changed.currentItog) {
					setData(text_1, ctx.currentItog);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (54:5) {#each currentScore as it}
	function create_each_block(component, ctx) {
		var li, text_value = ctx.it.question.properties.TITLE, text, text_1, b, text_2_value = ctx.it.strLen, text_2;

		return {
			c: function c() {
				li = createElement("li");
				text = createText(text_value);
				text_1 = createText(": ");
				b = createElement("b");
				text_2 = createText(text_2_value);
				li.className = "svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, li, anchor);
				append(li, text);
				append(li, text_1);
				append(li, b);
				append(b, text_2);
			},

			p: function p(changed, ctx) {
				if ((changed.currentScore) && text_value !== (text_value = ctx.it.question.properties.TITLE)) {
					setData(text, text_value);
				}

				if ((changed.currentScore) && text_2_value !== (text_2_value = ctx.it.strLen)) {
					setData(text_2, text_2_value);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(li);
				}
			}
		};
	}

	// (39:3) {#if resultQuestion}
	function create_if_block_5(component, ctx) {
		var div, span, text_value = ctx.emotion.title, text, text_1, span_1, text_2_value = ctx.emotion.score, text_2, text_4, text_5, hr, text_6, div_1, ul, text_8, hr_1, text_9, text_10;

		function select_block_type(ctx) {
			if (ctx.questions && ctx.questions.length) { return create_if_block_6; }
			return create_if_block_7;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		var each_value = ctx.currentScore;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c: function c() {
				div = createElement("div");
				span = createElement("span");
				text = createText(text_value);
				text_1 = createText("\r\n\t\t\t\t\t");
				span_1 = createElement("span");
				text_2 = createText(text_2_value);
				text_4 = createText("\r\n\t\t\t\t");
				if_block.c();
				text_5 = createText("\r\n\t\t\t\t");
				hr = createElement("hr");
				text_6 = createText("\r\n\t\t\t\t");
				div_1 = createElement("div");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_8 = createText("\r\n\t\t\t\t\t");
				hr_1 = createElement("hr");
				text_9 = createText("\r\n\t\t\t\t\tОбщий результат: ");
				text_10 = createText(ctx.currentItog);
				span.className = "emotionTitle";
				setStyle(span, "color", ctx.emotion.color);
				span_1.className = "emotionScore svelte-yzh5fj";
				div.className = "emotion svelte-yzh5fj";
				div_1.className = "question-result svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, text);
				append(div, text_1);
				append(div, span_1);
				append(span_1, text_2);
				insert(target, text_4, anchor);
				if_block.m(target, anchor);
				insert(target, text_5, anchor);
				insert(target, hr, anchor);
				insert(target, text_6, anchor);
				insert(target, div_1, anchor);
				append(div_1, ul);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				append(div_1, text_8);
				append(div_1, hr_1);
				append(div_1, text_9);
				append(div_1, text_10);
			},

			p: function p(changed, ctx) {
				if ((changed.emotion) && text_value !== (text_value = ctx.emotion.title)) {
					setData(text, text_value);
				}

				if (changed.emotion) {
					setStyle(span, "color", ctx.emotion.color);
				}

				if ((changed.emotion) && text_2_value !== (text_2_value = ctx.emotion.score)) {
					setData(text_2, text_2_value);
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(text_5.parentNode, text_5);
				}

				if (changed.currentScore) {
					each_value = ctx.currentScore;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.currentItog) {
					setData(text_10, ctx.currentItog);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
					detachNode(text_4);
				}

				if_block.d(detach);
				if (detach) {
					detachNode(text_5);
					detachNode(hr);
					detachNode(text_6);
					detachNode(div_1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (62:1) {#if point}
	function create_if_block_8(component, ctx) {
		var p, text_1, button;

		function click_handler(event) {
			component.set({calc:true});
		}

		return {
			c: function c() {
				p = createElement("p");
				p.textContent = "Вы уверены?";
				text_1 = createText("\r\n\t\t\t");
				button = createElement("button");
				button.textContent = "Подтвердить выбор";
				p.className = "standart svelte-yzh5fj";
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, p, anchor);
				insert(target, text_1, anchor);
				insert(target, button, anchor);
			},

			p: noop,

			d: function d(detach) {
				if (detach) {
					detachNode(p);
					detachNode(text_1);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (65:1) {:else}
	function create_if_block_9(component, ctx) {
		var p;

		return {
			c: function c() {
				p = createElement("p");
				p.textContent = "Кликните по карте в предпологаемом месте расположения объекта";
				p.className = "standart svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, p, anchor);
			},

			p: noop,

			d: function d(detach) {
				if (detach) {
					detachNode(p);
				}
			}
		};
	}

	// (79:3) {#each Object.keys(sectionsList) as it}
	function create_each_block_1(component, ctx) {
		var li, input, text_value = ctx.it, text;

		return {
			c: function c() {
				li = createElement("li");
				input = createElement("input");
				text = createText(text_value);
				input._svelte = { component: component, ctx: ctx };

				addListener(input, "change", change_handler);
				setAttribute(input, "type", "checkbox");
				input.checked = true;
			},

			m: function m(target, anchor) {
				insert(target, li, anchor);
				append(li, input);
				append(li, text);
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				input._svelte.ctx = ctx;
				if ((changed.Object || changed.sectionsList) && text_value !== (text_value = ctx.it)) {
					setData(text, text_value);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(li);
				}

				removeListener(input, "change", change_handler);
			}
		};
	}

	// (76:2) {#if sectionsList}
	function create_if_block_12(component, ctx) {
		var h1, text_1, ul, text_3, button;

		var each_value_1 = ctx.Object.keys(ctx.sectionsList);

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
		}

		function click_handler(event) {
			component.start();
		}

		return {
			c: function c() {
				h1 = createElement("h1");
				h1.textContent = "Рубрики";
				text_1 = createText("\r\n\t\t\t");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_3 = createText("\r\n\t\t\t");
				button = createElement("button");
				button.textContent = "Начать игру";
				h1.className = "section";
				ul.className = "selectSectionsList svelte-yzh5fj";
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
			},

			m: function m(target, anchor) {
				insert(target, h1, anchor);
				insert(target, text_1, anchor);
				insert(target, ul, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				insert(target, text_3, anchor);
				insert(target, button, anchor);
			},

			p: function p(changed, ctx) {
				if (changed.Object || changed.sectionsList) {
					each_value_1 = ctx.Object.keys(ctx.sectionsList);

					for (var i = 0; i < each_value_1.length; i += 1) {
						var child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}

				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(h1);
					detachNode(text_1);
					detachNode(ul);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(text_3);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (84:2) {:else}
	function create_if_block_13(component, ctx) {
		var div;

		return {
			c: function c() {
				div = createElement("div");
				div.innerHTML = "<div class=\"lds-ellipsis svelte-yzh5fj\"><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div></div>";
				div.className = "center svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
			},

			p: noop,

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (28:0) {#if quizList}
	function create_if_block_2(component, ctx) {
		var h1, text_1, p, text_3, if_block_anchor;

		var if_block = (!ctx.isSectionsEmpty) && create_if_block_3(component, ctx);

		return {
			c: function c() {
				h1 = createElement("h1");
				h1.textContent = "Добро пожаловать!";
				text_1 = createText("\r\n\t\t");
				p = createElement("p");
				p.textContent = "Мы рады приветствовать вас в нашем интерактивном географическом квесте!\r\n\tВ этой игре мы предлагаем выбрать рубрики, в рамках воторых вам предстоит находить места на карте, зная только их названия. Думаете просто?";
				text_3 = createText("\r\n\t\t");
				if (if_block) { if_block.c(); }
				if_block_anchor = createComment();
				h1.className = "title";
			},

			m: function m(target, anchor) {
				insert(target, h1, anchor);
				insert(target, text_1, anchor);
				insert(target, p, anchor);
				insert(target, text_3, anchor);
				if (if_block) { if_block.m(target, anchor); }
				insert(target, if_block_anchor, anchor);
			},

			p: function p(changed, ctx) {
				if (!ctx.isSectionsEmpty) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_3(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(h1);
					detachNode(text_1);
					detachNode(p);
					detachNode(text_3);
				}

				if (if_block) { if_block.d(detach); }
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (36:18) 
	function create_if_block_4(component, ctx) {
		var div, text_value = ctx.question ? ctx.question.properties.TITLE + ' (' + ctx.question.properties.SECTION + ')' : '', text, text_1;

		function select_block_type_1(ctx) {
			if (ctx.resultQuestion) { return create_if_block_5; }
			if (ctx.point) { return create_if_block_8; }
			return create_if_block_9;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function c() {
				div = createElement("div");
				text = createText(text_value);
				text_1 = createText("?\r\n\t\t\t");
				if_block.c();
				div.className = "question svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				append(div, text_1);
				if_block.m(div, null);
			},

			p: function p(changed, ctx) {
				if ((changed.question) && text_value !== (text_value = ctx.question ? ctx.question.properties.TITLE + ' (' + ctx.question.properties.SECTION + ')' : '')) {
					setData(text, text_value);
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
			}
		};
	}

	// (70:18) 
	function create_if_block_10(component, ctx) {
		var div;

		return {
			c: function c() {
				div = createElement("div");
				div.innerHTML = "<div class=\"lds-ellipsis svelte-yzh5fj\"><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div><div class=\"svelte-yzh5fj\"></div></div>";
				div.className = "center svelte-yzh5fj";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
			},

			p: noop,

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (74:0) {:else}
	function create_if_block_11(component, ctx) {
		var div;

		function select_block_type_2(ctx) {
			if (ctx.sectionsList) { return create_if_block_12; }
			return create_if_block_13;
		}

		var current_block_type = select_block_type_2(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function c() {
				div = createElement("div");
				if_block.c();
				div.className = "subcontent";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
			},

			p: function p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
			}
		};
	}

	function get_each_context(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		child_ctx.each_value = list;
		child_ctx.it_index = i;
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.it_index_1 = i;
		return child_ctx;
	}

	function change_handler(event) {
		var ref = this._svelte;
		var component = ref.component;
		var ctx = ref.ctx;

		component.checkSection(ctx.it, this.checked);
	}

	function App(options) {
		var this$1 = this;

		init(this, options);
		this._state = assign(assign({ Object : Object }, data$1()), options.data);
		this._recompute({ currentScore: 1, sectionsList: 1 }, this._state);
		this._intro = !!options.intro;

		this._handlers.state = [onstate$1];

		onstate$1.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment$1(this, this._state);

		this.root._oncreate.push(function () {
			this$1.fire("update", { changed: assignTrue({}, this$1._state), current: this$1._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(App.prototype, proto);
	assign(App.prototype, methods$1);

	App.prototype._recompute = function _recompute(changed, state) {
		if (changed.currentScore) {
			if (this._differs(state.currentItog, (state.currentItog = currentItog(state)))) { changed.currentItog = true; }
		}

		if (changed.sectionsList) {
			if (this._differs(state.isSectionsEmpty, (state.isSectionsEmpty = isSectionsEmpty(state)))) { changed.isSectionsEmpty = true; }
		}
	};

	var app = new App({
		target: document.body,
		//target: document.getElementsByClassName('editor-sidebarContainer')[0] || document.body,
		data: {
		}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
