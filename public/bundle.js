var app = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function addLoc(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file: file, line: line, column: column, char:char }
		};
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var protoDev = {
		destroy: destroyDev,
		get: get,
		fire: fire,
		on: on,
		set: setDev,
		_recompute: noop,
		_set: _set,
		_stage: _stage,
		_mount: _mount,
		_differs: _differs
	};

	/* src\Map.html generated by Svelte v2.13.5 */

	var serverBase = window.serverBase || '//maps.kosmosnimki.ru/';
	var apikey = 'PBZU2XXPDM';
	var sectionsLen = 10;
	var questionLen = 10;
	var gameZoom = 3;

	function data() {
		return {
			quizList: null,
			questions: null,
			permalink: null,
			map: null
		}
	}
	var methods = {
		getSections: function(arr) {
			var sections = {};
			arr.forEach(function(it) {
				var key = it.properties.SECTION;
				if (!sections[key]) { sections[key] = []; }			sections[key].push(it);
			});
			var arrSections = Object.keys(sections).sort(() => Math.random() > 0.5 ),
				len = arrSections.length,
				sections1 = {};
			// console.log('llll', arrSections);
			for(var i = 0, len1 = len > sectionsLen ? sectionsLen : len; i < len1; i++) {
				var key = arrSections[i];
				sections1[key] = sections[key];
			}
			this.set({sectionsList: sections1});
		},
		reBuildQuestions: function(sectionsList) {
			var arr = [],
				sectionsKeyArr = Object.keys(sectionsList),
				sectionsLen = sectionsKeyArr.length;

			for(var i = 0; i < questionLen; i++) {
				var key = sectionsKeyArr[Math.floor(sectionsLen * Math.random())],
					arr1 = sectionsList[key],
					len1 = arr1.length;
				arr.push(arr1[Math.floor(len1 * Math.random())]);
			}

			// this.allData.sort(()=>Math.random() > 0.5).forEach(function(it) {
				// let props = it.properties,
					// id = props.gmx_id,
					// key = props.SECTION;
				// if (!ids[id] && sectionsList[key]) {
					// arr.push(it);
					// ids[id] = true;
				// }
			// });
			// console.log('reBuildQuestions', arr);
			this.set({questions: arr, reBuildQuestions: false});
			// this.set({questions: arr.slice(0, questionLen), reBuildQuestions: false});
		},
		getQuestion: function(question) {
			var {layerID} = this.get();

			this.question = null;
			var query = 'gmx_id=' + question.properties.gmx_id,
				url = serverBase + 'rest/ver1/layers/' + layerID + '/search?apikey=' + apikey + '&query=' + query;
			fetch(url, {mode: 'cors'})
				.then(function(resp) { return resp.json(); })
				.then(function(json) {
					this.question = json.features[0];
					if (this.needResult) {
						this.showQuestionResult();
						this.needResult = false;
					}
				}.bind(this));

			this._clearLayers();
			this.map.setZoom(gameZoom);
		},
		getLayerGame: function(layerID) {
			var url = serverBase + 'rest/ver1/layers/' + layerID + '/search?apikey=' + apikey + '&columns=[{%22Value%22:%22[gmx_id]%22},{%22Value%22:%22[TITLE]%22},{%22Value%22:%22SECTION%22}]';
			fetch(url, {mode: 'cors'})
				.then(function(resp) { return resp.json(); })
				.then(function(json) {
					this.allData = json.features;
				}.bind(this));
		},
		showQuestionResult: function() {
			// if (this.polyline) { this.map.removeLayer(this.polyline); }
			var {emotions} = this.get(),
				item = this.question,
				layers = L.geoJSON(item.geometry).getLayers(),
				closestLayer = L.GeometryUtil.closestLayer(this.map, layers, this._latlng),
				closest = L.GeometryUtil.closest(this.map, closestLayer.layer, this._latlng, false),

				currentLayer = closestLayer.layer,
				bounds = currentLayer.getBounds(),
				isContains = bounds.contains(this._latlng),
				
				polyline = L.geodesic([[closest, this._latlng]], {color: 'red'}).addTo(this.map);

			this.map.fitBounds(polyline.getBounds());
			var geoJson = polyline.toGeoJSON().geometry;

			this.currentLayer = currentLayer.addTo(this.map);
			this.polyline = polyline;
			var lenM = L.gmxUtil.geoJSONGetLength(geoJson),
				lenKm = Math.round(lenM / 1000),
				strLen = L.gmxUtil.getGeoJSONSummary(geoJson),
				resultQuestion = {},
				// sc = 0,
				emotion;
			for (var i = 0, c, p, len = emotions.emotion.length; i < len; i++) {
				c = emotions.emotion[i];
				if (c.error > lenKm || i === len - 1) {
					var it = i === len - 1 ? c : p || c;
					emotion = {title: emotions.rank[it.rank], color: it.color, score: strLen};
					break;
				}
				p = c;
			}
			
			if (isContains) {
				// sc = 10;
				emotion = {title: 'ВАУ, КРУТО!', score: ''};
				// resultQuestion.ok = sc + ' баллов';
				if (this.audioStarted) this.audio.stop(0);
				this.audioStart(11.74689342403628, 3.82984126984127);
			} else {
				this.audioStart(8.50453514739229, 0.20950113378684806);
				
			}
			resultQuestion.question = item;
			resultQuestion.len = isContains ? 0 : lenM;
			resultQuestion.strLen = isContains ? '0' : strLen;
			this.set({resultQuestion: resultQuestion, emotion: emotion});
		},
		clickMap: function(ev) {
			if (this.marker) {
				this.map.removeLayer(this.marker);
			}
			this._latlng = ev.latlng;
			this.marker = L.marker(this._latlng, {icon: L.divIcon({className: 'my-div-icon', iconSize: [4, 4], iconAnchor:[10, 10]})}).addTo(this.map);
			
			this.set({point: true});
		},
		audioStart: function(start, duration) {
			if (this.sound) {
				var audioCtx = new (window.AudioContext || window.webkitAudioContext)(),
					source = audioCtx.createBufferSource(),
					request = new XMLHttpRequest();
				request.open('GET', 'mp3/audio.mp3', true);
				request.responseType = 'arraybuffer';
				request.onload = function() {
					audioCtx.decodeAudioData(request.response, function(buffer) {
						source.buffer = buffer;
						source.start(audioCtx.currentTime + 1, start, duration);
						source.connect(audioCtx.destination);
						// source.loop = true;
					  },

					  function(e){ console.log("Error with decoding audio data" + e.err); }
					);
				};
				request.send();
			}
		},
		_clearLayers: function() {
			if (this.marker) { this.map.removeLayer(this.marker); this.marker = null; }
			if (this.polyline) { this.map.removeLayer(this.polyline); this.polyline = null; }
			if (this.currentLayer) { this.map.removeLayer(this.currentLayer); this.currentLayer = null; }
		},
		createMap: function(it) {
			var state = it.state || {},
				mapID = it.mapID || 'A557835E1B2344479C092FBB0158B529',
				layerID = it.layerID || 'F9728D94848F4163A19DF5B5A6BFDDF1', //'5F2A707A119A45EF9BD490187E909830',
				apiKey = it.apiKey,
				pos = state.map ? state.map.position : {};

			this.sound = it.sound;

			var osm = it.base == 1 ? 
				L.tileLayer('//tilessputnik.ru/{z}/{x}/{y}.png', {
	                        attribution: '<a href="http://maps.sputnik.ru">Спутник</a> © Ростелеком | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
					maxNativeZoom: 18,
					maxZoom: 21
				}) :
				L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1Ijoia29zbW9zbmlta2kiLCJhIjoiY2lvbW1tNXN0MDAwdnc4bHg5ZWw2YXJtYSJ9.ON9Ovi3fuHc5RAipmLb2EQ', {
					attribution: '&copy; <a href="//mapbox.com/">mapbox</a>',
					maxNativeZoom: 18,
					maxZoom: 21
				});

			var map = new L.Map('map', {
				attribution: '&copy; <a href="//scanex.ru/">scanex</a>',
				allWorld: true,
				generalized: false,
				layers: [osm],
				center: new L.LatLng(pos.y || 26, pos.x || 83),
				zoom: pos.z || 7
			}).on('click', this.clickMap.bind(this), this);

			// map.gmxControlsManager.init();
			map.zoomControl.setPosition('bottomright');
			if (layerID) {
				this.getLayerGame(layerID);
			}
			this.quizList = true;
			this.map = map;
		}
	};

	function oncreate() {
		var {urlParams} = this.get();
		this.createMap(urlParams);
	}
	function onstate({ changed, current, previous }) {
		// console.log('in onstate', this);
		if (changed.selectQuiz && current.selectQuiz) {
			this._clearLayers();
			this.set({quizList: this.quizList});
		} else if (changed.layerID && current.layerID) {
			this.getSections(this.allData);
		} else if (changed.question && current.question) {
			this.getQuestion(current.question);
		} else if (current.reBuildQuestions) {
			this.reBuildQuestions(current.sectionsList);
		} else if (changed.calc && current.calc) {
			if (this.question) {
				this.showQuestionResult();
			} else {
				this.needResult = true;
			}
		}
	}
	const file = "src\\Map.html";

	function create_main_fragment(component, ctx) {
		var div, current;

		return {
			c: function create() {
				div = createElement("div");
				div.id = "map";
				addLoc(div, file, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function Map(options) {
		this._debugName = '<Map>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data(), options.data);
		this._intro = !!options.intro;

		this._handlers.state = [onstate];

		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Map.prototype, protoDev);
	assign(Map.prototype, methods);

	Map.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src\App.html generated by Svelte v2.13.5 */

	function currentItog({ currentScore }) {
		return L.gmxUtil.prettifyDistance(currentScore.reduce((p, c) => p + c.len, 0));
	}

	function isSectionsEmpty({ sectionsList }) {
		var res = false;
		if (sectionsList) {
			res = true;
			for(var key in sectionsList) {
				if (sectionsList[key]) { res = false; break; }
			}
		}
		return res;
	}

	function data$1() {
		return {
			urlParams: {},
			quizList: [],
			selectQuiz: null,
			sectionsList: null,
			layerID: '',
			// layerGame: false,
			questions: false,
			question: false,
			point: false,
			calc: false,
			emotion: false,
			emotions: emotions,
			resultQuestion: false,
			reBuildQuestions: false,
			// props: {},
			currentScore: [],
			score: null
		}
	}
	var methods$1 = {
		checkSection(key, flag) {
			// console.log('checkSection', key, flag);
			var {sectionsList} = this.get();
			sectionsList[key] = flag;
			this.set({sectionsList: sectionsList});
		},
		start() {
			//this.set({quizList: 1});
			this.set({reBuildQuestions: true, quizList: null, layerID: 'F9728D94848F4163A19DF5B5A6BFDDF1'});
			this.nextQuestion(0, true);
		},
		nextQuestion(sc, clearCurrentScore) {
			var {questions, props, score, currentScore} = this.get(),
				question = questions.shift();
			if (clearCurrentScore) { currentScore = []; }
			this.set({questions: questions, question: question, point: false, calc: false, resultQuestion: false, currentScore: currentScore});
		}
	};

	function onstate$1({ changed, current, previous }) {
		// console.log('in onstate', this);
		if (changed.resultQuestion && current.resultQuestion) {
			var {currentScore} = this.get();
			currentScore.push(current.resultQuestion);
			this.set({currentScore: currentScore});
		}
	}
	const file$1 = "src\\App.html";

	function create_main_fragment$1(component, ctx) {
		var map_updating = {}, text, text_1, div, div_1, text_3, div_2, current;

		var map_initial_data = { urlParams: ctx.urlParams };
		if (ctx.selectQuiz
		 !== void 0) {
			map_initial_data.selectQuiz = ctx.selectQuiz
		;
			map_updating.selectQuiz = true;
		}
		if (ctx.sectionsList
		 !== void 0) {
			map_initial_data.sectionsList = ctx.sectionsList
		;
			map_updating.sectionsList = true;
		}
		if (ctx.quizList
		 !== void 0) {
			map_initial_data.quizList = ctx.quizList
		;
			map_updating.quizList = true;
		}
		if (ctx.layerID
		 !== void 0) {
			map_initial_data.layerID = ctx.layerID
		;
			map_updating.layerID = true;
		}
		if (ctx.layerGame
		 !== void 0) {
			map_initial_data.layerGame = ctx.layerGame
		;
			map_updating.layerGame = true;
		}
		if (ctx.score
		 !== void 0) {
			map_initial_data.score = ctx.score
		;
			map_updating.score = true;
		}
		if (ctx.questions
		 !== void 0) {
			map_initial_data.questions = ctx.questions
		;
			map_updating.questions = true;
		}
		if (ctx.question
		 !== void 0) {
			map_initial_data.question = ctx.question
		;
			map_updating.question = true;
		}
		if (ctx.point
		 !== void 0) {
			map_initial_data.point = ctx.point
		;
			map_updating.point = true;
		}
		if (ctx.calc
		 !== void 0) {
			map_initial_data.calc = ctx.calc
		;
			map_updating.calc = true;
		}
		if (ctx.emotion
		 !== void 0) {
			map_initial_data.emotion = ctx.emotion
		;
			map_updating.emotion = true;
		}
		if (ctx.emotions
		 !== void 0) {
			map_initial_data.emotions = ctx.emotions
		;
			map_updating.emotions = true;
		}
		if (ctx.resultQuestion
		 !== void 0) {
			map_initial_data.resultQuestion = ctx.resultQuestion
		;
			map_updating.resultQuestion = true;
		}
		if (ctx.reBuildQuestions
	 !== void 0) {
			map_initial_data.reBuildQuestions = ctx.reBuildQuestions
	;
			map_updating.reBuildQuestions = true;
		}
		var map = new Map({
			root: component.root,
			store: component.store,
			data: map_initial_data,
			_bind(changed, childState) {
				var newState = {};
				if (!map_updating.selectQuiz && changed.selectQuiz) {
					newState.selectQuiz = childState.selectQuiz;
				}

				if (!map_updating.sectionsList && changed.sectionsList) {
					newState.sectionsList = childState.sectionsList;
				}

				if (!map_updating.quizList && changed.quizList) {
					newState.quizList = childState.quizList;
				}

				if (!map_updating.layerID && changed.layerID) {
					newState.layerID = childState.layerID;
				}

				if (!map_updating.layerGame && changed.layerGame) {
					newState.layerGame = childState.layerGame;
				}

				if (!map_updating.score && changed.score) {
					newState.score = childState.score;
				}

				if (!map_updating.questions && changed.questions) {
					newState.questions = childState.questions;
				}

				if (!map_updating.question && changed.question) {
					newState.question = childState.question;
				}

				if (!map_updating.point && changed.point) {
					newState.point = childState.point;
				}

				if (!map_updating.calc && changed.calc) {
					newState.calc = childState.calc;
				}

				if (!map_updating.emotion && changed.emotion) {
					newState.emotion = childState.emotion;
				}

				if (!map_updating.emotions && changed.emotions) {
					newState.emotions = childState.emotions;
				}

				if (!map_updating.resultQuestion && changed.resultQuestion) {
					newState.resultQuestion = childState.resultQuestion;
				}

				if (!map_updating.reBuildQuestions && changed.reBuildQuestions) {
					newState.reBuildQuestions = childState.reBuildQuestions;
				}
				component._set(newState);
				map_updating = {};
			}
		});

		component.root._beforecreate.push(() => {
			map._bind({ selectQuiz: 1, sectionsList: 1, quizList: 1, layerID: 1, layerGame: 1, score: 1, questions: 1, question: 1, point: 1, calc: 1, emotion: 1, emotions: 1, resultQuestion: 1, reBuildQuestions: 1 }, map.get());
		});

		var if_block = (!ctx.question) && create_if_block(component, ctx);

		var if_block_1 = (ctx.question) && create_if_block_1(component, ctx);

		function select_block_type_3(ctx) {
			if (ctx.quizList) return create_if_block_2;
			if (ctx.question) return create_if_block_3;
			if (!ctx.layerID) return create_if_block_9;
			return create_if_block_10;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block_2 = current_block_type(component, ctx);

		return {
			c: function create() {
				map._fragment.c();
				text = createText("\r\n");
				if (if_block) if_block.c();
				text_1 = createText("\r\n");
				div = createElement("div");
				div_1 = createElement("div");
				if (if_block_1) if_block_1.c();
				text_3 = createText("\r\n\t");
				div_2 = createElement("div");
				if_block_2.c();
				div_1.className = "title bg svelte-yzh5fj";
				addLoc(div_1, file$1, 20, 1, 342);
				div_2.className = "content svelte-yzh5fj";
				addLoc(div_2, file$1, 25, 1, 513);
				div.className = "controls svelte-yzh5fj";
				addLoc(div, file$1, 19, 0, 317);
			},

			m: function mount(target, anchor) {
				map._mount(target, anchor);
				insert(target, text, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, text_1, anchor);
				insert(target, div, anchor);
				append(div, div_1);
				if (if_block_1) if_block_1.m(div_1, null);
				append(div, text_3);
				append(div, div_2);
				if_block_2.m(div_2, null);
				current = true;
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				var map_changes = {};
				if (changed.urlParams) map_changes.urlParams = ctx.urlParams;
				if (!map_updating.selectQuiz && changed.selectQuiz) {
					map_changes.selectQuiz = ctx.selectQuiz
		;
					map_updating.selectQuiz = ctx.selectQuiz
		 !== void 0;
				}
				if (!map_updating.sectionsList && changed.sectionsList) {
					map_changes.sectionsList = ctx.sectionsList
		;
					map_updating.sectionsList = ctx.sectionsList
		 !== void 0;
				}
				if (!map_updating.quizList && changed.quizList) {
					map_changes.quizList = ctx.quizList
		;
					map_updating.quizList = ctx.quizList
		 !== void 0;
				}
				if (!map_updating.layerID && changed.layerID) {
					map_changes.layerID = ctx.layerID
		;
					map_updating.layerID = ctx.layerID
		 !== void 0;
				}
				if (!map_updating.layerGame && changed.layerGame) {
					map_changes.layerGame = ctx.layerGame
		;
					map_updating.layerGame = ctx.layerGame
		 !== void 0;
				}
				if (!map_updating.score && changed.score) {
					map_changes.score = ctx.score
		;
					map_updating.score = ctx.score
		 !== void 0;
				}
				if (!map_updating.questions && changed.questions) {
					map_changes.questions = ctx.questions
		;
					map_updating.questions = ctx.questions
		 !== void 0;
				}
				if (!map_updating.question && changed.question) {
					map_changes.question = ctx.question
		;
					map_updating.question = ctx.question
		 !== void 0;
				}
				if (!map_updating.point && changed.point) {
					map_changes.point = ctx.point
		;
					map_updating.point = ctx.point
		 !== void 0;
				}
				if (!map_updating.calc && changed.calc) {
					map_changes.calc = ctx.calc
		;
					map_updating.calc = ctx.calc
		 !== void 0;
				}
				if (!map_updating.emotion && changed.emotion) {
					map_changes.emotion = ctx.emotion
		;
					map_updating.emotion = ctx.emotion
		 !== void 0;
				}
				if (!map_updating.emotions && changed.emotions) {
					map_changes.emotions = ctx.emotions
		;
					map_updating.emotions = ctx.emotions
		 !== void 0;
				}
				if (!map_updating.resultQuestion && changed.resultQuestion) {
					map_changes.resultQuestion = ctx.resultQuestion
		;
					map_updating.resultQuestion = ctx.resultQuestion
		 !== void 0;
				}
				if (!map_updating.reBuildQuestions && changed.reBuildQuestions) {
					map_changes.reBuildQuestions = ctx.reBuildQuestions
	;
					map_updating.reBuildQuestions = ctx.reBuildQuestions
	 !== void 0;
				}
				map._set(map_changes);
				map_updating = {};

				if (!ctx.question) {
					if (!if_block) {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(text_1.parentNode, text_1);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (ctx.question) {
					if (if_block_1) {
						if_block_1.p(changed, ctx);
					} else {
						if_block_1 = create_if_block_1(component, ctx);
						if_block_1.c();
						if_block_1.m(div_1, null);
					}
				} else if (if_block_1) {
					if_block_1.d(1);
					if_block_1 = null;
				}

				if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block_2) {
					if_block_2.p(changed, ctx);
				} else {
					if_block_2.d(1);
					if_block_2 = current_block_type(component, ctx);
					if_block_2.c();
					if_block_2.m(div_2, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (map) map._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy$$1(detach) {
				map.destroy(detach);
				if (detach) {
					detachNode(text);
				}

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(text_1);
					detachNode(div);
				}

				if (if_block_1) if_block_1.d();
				if_block_2.d();
			}
		};
	}

	// (17:0) {#if !question}
	function create_if_block(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "scrim svelte-yzh5fj";
				addLoc(div, file$1, 17, 0, 283);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (22:1) {#if question}
	function create_if_block_1(component, ctx) {
		var button, text;

		function click_handler(event) {
			component.set({question:''});
		}

		return {
			c: function create() {
				button = createElement("button");
				text = createText("Начать игру заново");
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
				addLoc(button, file$1, 22, 2, 385);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, text);
			},

			p: function update(changed, ctx) {
				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (41:4) {#if questions && questions.length}
	function create_if_block_5(component, ctx) {
		var button, text;

		function click_handler(event) {
			component.nextQuestion();
		}

		return {
			c: function create() {
				button = createElement("button");
				text = createText("Следующий вопрос");
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				addLoc(button, file$1, 41, 4, 1373);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, text);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (43:4) {:else}
	function create_if_block_6(component, ctx) {
		var div, text, span, text_1;

		return {
			c: function create() {
				div = createElement("div");
				text = createText("Ваш итоговый результат: ");
				span = createElement("span");
				text_1 = createText(ctx.currentItog);
				span.className = "red svelte-yzh5fj";
				addLoc(span, file$1, 44, 29, 1514);
				div.className = "itog";
				addLoc(div, file$1, 43, 4, 1465);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				append(div, span);
				append(span, text_1);
			},

			p: function update(changed, ctx) {
				if (changed.currentItog) {
					setData(text_1, ctx.currentItog);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (51:5) {#each currentScore as it}
	function create_each_block(component, ctx) {
		var li, text_value = ctx.it.question.properties.TITLE, text, text_1, b, text_2_value = ctx.it.strLen, text_2;

		return {
			c: function create() {
				li = createElement("li");
				text = createText(text_value);
				text_1 = createText(": ");
				b = createElement("b");
				text_2 = createText(text_2_value);
				addLoc(b, file$1, 51, 42, 1710);
				li.className = "svelte-yzh5fj";
				addLoc(li, file$1, 51, 6, 1674);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, text);
				append(li, text_1);
				append(li, b);
				append(b, text_2);
			},

			p: function update(changed, ctx) {
				if ((changed.currentScore) && text_value !== (text_value = ctx.it.question.properties.TITLE)) {
					setData(text, text_value);
				}

				if ((changed.currentScore) && text_2_value !== (text_2_value = ctx.it.strLen)) {
					setData(text_2, text_2_value);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(li);
				}
			}
		};
	}

	// (36:3) {#if resultQuestion}
	function create_if_block_4(component, ctx) {
		var div, span, text_value = ctx.emotion.title, text, text_1, span_1, text_2_value = ctx.emotion.score, text_2, text_4, text_5, hr, text_6, div_1, ul, text_8, hr_1, text_9, text_10;

		function select_block_type(ctx) {
			if (ctx.questions && ctx.questions.length) return create_if_block_5;
			return create_if_block_6;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		var each_value = ctx.currentScore;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c: function create() {
				div = createElement("div");
				span = createElement("span");
				text = createText(text_value);
				text_1 = createText("\r\n\t\t\t\t\t");
				span_1 = createElement("span");
				text_2 = createText(text_2_value);
				text_4 = createText("\r\n\t\t\t\t");
				if_block.c();
				text_5 = createText("\r\n\t\t\t\t");
				hr = createElement("hr");
				text_6 = createText("\r\n\t\t\t\t");
				div_1 = createElement("div");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_8 = createText("\r\n\t\t\t\t\t");
				hr_1 = createElement("hr");
				text_9 = createText("\r\n\t\t\t\t\tОбщий результат: ");
				text_10 = createText(ctx.currentItog);
				span.className = "emotionTitle";
				setStyle(span, "color", ctx.emotion.color);
				addLoc(span, file$1, 37, 5, 1178);
				span_1.className = "emotionScore svelte-yzh5fj";
				addLoc(span_1, file$1, 38, 5, 1265);
				div.className = "emotion svelte-yzh5fj";
				addLoc(div, file$1, 36, 4, 1150);
				addLoc(hr, file$1, 47, 4, 1581);
				addLoc(ul, file$1, 49, 5, 1629);
				addLoc(hr_1, file$1, 54, 5, 1766);
				div_1.className = "question-result svelte-yzh5fj";
				addLoc(div_1, file$1, 48, 4, 1593);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, text);
				append(div, text_1);
				append(div, span_1);
				append(span_1, text_2);
				insert(target, text_4, anchor);
				if_block.m(target, anchor);
				insert(target, text_5, anchor);
				insert(target, hr, anchor);
				insert(target, text_6, anchor);
				insert(target, div_1, anchor);
				append(div_1, ul);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				append(div_1, text_8);
				append(div_1, hr_1);
				append(div_1, text_9);
				append(div_1, text_10);
			},

			p: function update(changed, ctx) {
				if ((changed.emotion) && text_value !== (text_value = ctx.emotion.title)) {
					setData(text, text_value);
				}

				if (changed.emotion) {
					setStyle(span, "color", ctx.emotion.color);
				}

				if ((changed.emotion) && text_2_value !== (text_2_value = ctx.emotion.score)) {
					setData(text_2, text_2_value);
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(text_5.parentNode, text_5);
				}

				if (changed.currentScore) {
					each_value = ctx.currentScore;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.currentItog) {
					setData(text_10, ctx.currentItog);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
					detachNode(text_4);
				}

				if_block.d(detach);
				if (detach) {
					detachNode(text_5);
					detachNode(hr);
					detachNode(text_6);
					detachNode(div_1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (59:1) {#if point}
	function create_if_block_7(component, ctx) {
		var p, text, text_1, button, text_2;

		function click_handler(event) {
			component.set({calc:true});
		}

		return {
			c: function create() {
				p = createElement("p");
				text = createText("Вы уверены?");
				text_1 = createText("\r\n\t\t\t");
				button = createElement("button");
				text_2 = createText("Подтвердить выбор");
				p.className = "standart svelte-yzh5fj";
				addLoc(p, file$1, 59, 3, 1852);
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				addLoc(button, file$1, 60, 3, 1892);
			},

			m: function mount(target, anchor) {
				insert(target, p, anchor);
				append(p, text);
				insert(target, text_1, anchor);
				insert(target, button, anchor);
				append(button, text_2);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(p);
					detachNode(text_1);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (62:1) {:else}
	function create_if_block_8(component, ctx) {
		var p, text;

		return {
			c: function create() {
				p = createElement("p");
				text = createText("Кликните по карте в предпологаемом месте расположения объекта");
				p.className = "standart svelte-yzh5fj";
				addLoc(p, file$1, 62, 3, 1983);
			},

			m: function mount(target, anchor) {
				insert(target, p, anchor);
				append(p, text);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(p);
				}
			}
		};
	}

	// (76:3) {#each Object.keys(sectionsList) as it}
	function create_each_block_1(component, ctx) {
		var li, input, text_value = ctx.it, text;

		return {
			c: function create() {
				li = createElement("li");
				input = createElement("input");
				text = createText(text_value);
				input._svelte = { component, ctx };

				addListener(input, "change", change_handler);
				setAttribute(input, "type", "checkbox");
				input.checked = true;
				addLoc(input, file$1, 76, 8, 2417);
				addLoc(li, file$1, 76, 4, 2413);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, input);
				append(li, text);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				input._svelte.ctx = ctx;
				if ((changed.Object || changed.sectionsList) && text_value !== (text_value = ctx.it)) {
					setData(text, text_value);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(li);
				}

				removeListener(input, "change", change_handler);
			}
		};
	}

	// (73:2) {#if sectionsList}
	function create_if_block_11(component, ctx) {
		var h1, text, text_1, ul, text_3, button, text_4;

		var each_value_1 = ctx.Object.keys(ctx.sectionsList);

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
		}

		function click_handler(event) {
			component.start();
		}

		return {
			c: function create() {
				h1 = createElement("h1");
				text = createText("Рубрики");
				text_1 = createText("\r\n\t\t\t");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_3 = createText("\r\n\t\t\t");
				button = createElement("button");
				text_4 = createText("Начать игру");
				h1.className = "section";
				addLoc(h1, file$1, 73, 3, 2295);
				ul.className = "selectSectionsList svelte-yzh5fj";
				addLoc(ul, file$1, 74, 3, 2332);
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
				addLoc(button, file$1, 79, 3, 2528);
			},

			m: function mount(target, anchor) {
				insert(target, h1, anchor);
				append(h1, text);
				insert(target, text_1, anchor);
				insert(target, ul, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				insert(target, text_3, anchor);
				insert(target, button, anchor);
				append(button, text_4);
			},

			p: function update(changed, ctx) {
				if (changed.Object || changed.sectionsList) {
					each_value_1 = ctx.Object.keys(ctx.sectionsList);

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}

				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(h1);
					detachNode(text_1);
					detachNode(ul);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(text_3);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (81:2) {:else}
	function create_if_block_12(component, ctx) {
		var div, div_1, div_2, div_3, div_4, div_5;

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				div_2 = createElement("div");
				div_3 = createElement("div");
				div_4 = createElement("div");
				div_5 = createElement("div");
				div_2.className = "svelte-yzh5fj";
				addLoc(div_2, file$1, 81, 49, 2680);
				div_3.className = "svelte-yzh5fj";
				addLoc(div_3, file$1, 81, 60, 2691);
				div_4.className = "svelte-yzh5fj";
				addLoc(div_4, file$1, 81, 71, 2702);
				div_5.className = "svelte-yzh5fj";
				addLoc(div_5, file$1, 81, 82, 2713);
				div_1.className = "lds-ellipsis svelte-yzh5fj";
				addLoc(div_1, file$1, 81, 23, 2654);
				div.className = "center svelte-yzh5fj";
				addLoc(div, file$1, 81, 3, 2634);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, div_1);
				append(div_1, div_2);
				append(div_1, div_3);
				append(div_1, div_4);
				append(div_1, div_5);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (27:0) {#if quizList}
	function create_if_block_2(component, ctx) {
		var h1, text, text_1, p, text_2, text_3, button, text_4;

		function click_handler(event) {
			component.set({quizList: null, layerID: 'F9728D94848F4163A19DF5B5A6BFDDF1'});
		}

		return {
			c: function create() {
				h1 = createElement("h1");
				text = createText("Добро пожаловать!");
				text_1 = createText("\r\n\t\t");
				p = createElement("p");
				text_2 = createText("Мы рады приветствовать вас в нашем интерактивном географическом квесте!\r\n\tВ этой игре мы предлагаем выбрать рубрики, в рамках воторых вам предстоит находить места на карте, зная только их названия. Думаете просто?");
				text_3 = createText("\r\n\t\t");
				button = createElement("button");
				text_4 = createText("Давайте проверим!");
				h1.className = "title";
				addLoc(h1, file$1, 27, 2, 554);
				addLoc(p, file$1, 28, 2, 598);
				addListener(button, "click", click_handler);
				button.className = "start svelte-yzh5fj";
				button.disabled = ctx.isSectionsEmpty;
				addLoc(button, file$1, 31, 2, 826);
			},

			m: function mount(target, anchor) {
				insert(target, h1, anchor);
				append(h1, text);
				insert(target, text_1, anchor);
				insert(target, p, anchor);
				append(p, text_2);
				insert(target, text_3, anchor);
				insert(target, button, anchor);
				append(button, text_4);
			},

			p: function update(changed, ctx) {
				if (changed.isSectionsEmpty) {
					button.disabled = ctx.isSectionsEmpty;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(h1);
					detachNode(text_1);
					detachNode(p);
					detachNode(text_3);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (33:18) 
	function create_if_block_3(component, ctx) {
		var div, text_value = ctx.question ? ctx.question.properties.TITLE + ' (' + ctx.question.properties.SECTION + ')' : '', text, text_1;

		function select_block_type_1(ctx) {
			if (ctx.resultQuestion) return create_if_block_4;
			if (ctx.point) return create_if_block_7;
			return create_if_block_8;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				text_1 = createText("?\r\n\t\t\t");
				if_block.c();
				div.className = "question svelte-yzh5fj";
				addLoc(div, file$1, 33, 2, 1005);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				append(div, text_1);
				if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if ((changed.question) && text_value !== (text_value = ctx.question ? ctx.question.properties.TITLE + ' (' + ctx.question.properties.SECTION + ')' : '')) {
					setData(text, text_value);
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
			}
		};
	}

	// (67:18) 
	function create_if_block_9(component, ctx) {
		var div, div_1, div_2, div_3, div_4, div_5;

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				div_2 = createElement("div");
				div_3 = createElement("div");
				div_4 = createElement("div");
				div_5 = createElement("div");
				div_2.className = "svelte-yzh5fj";
				addLoc(div_2, file$1, 68, 29, 2171);
				div_3.className = "svelte-yzh5fj";
				addLoc(div_3, file$1, 68, 40, 2182);
				div_4.className = "svelte-yzh5fj";
				addLoc(div_4, file$1, 68, 51, 2193);
				div_5.className = "svelte-yzh5fj";
				addLoc(div_5, file$1, 68, 62, 2204);
				div_1.className = "lds-ellipsis svelte-yzh5fj";
				addLoc(div_1, file$1, 68, 3, 2145);
				div.className = "center svelte-yzh5fj";
				addLoc(div, file$1, 67, 2, 2120);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, div_1);
				append(div_1, div_2);
				append(div_1, div_3);
				append(div_1, div_4);
				append(div_1, div_5);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (71:0) {:else}
	function create_if_block_10(component, ctx) {
		var div;

		function select_block_type_2(ctx) {
			if (ctx.sectionsList) return create_if_block_11;
			return create_if_block_12;
		}

		var current_block_type = select_block_type_2(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if_block.c();
				div.className = "subcontent";
				addLoc(div, file$1, 71, 2, 2244);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
			}
		};
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		child_ctx.each_value = list;
		child_ctx.it_index = i;
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.it_index_1 = i;
		return child_ctx;
	}

	function change_handler(event) {
		const { component, ctx } = this._svelte;

		component.checkSection(ctx.it, this.checked);
	}

	function App(options) {
		this._debugName = '<App>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(assign({ Object : Object }, data$1()), options.data);
		this._recompute({ currentScore: 1, sectionsList: 1 }, this._state);
		if (!('currentScore' in this._state)) console.warn("<App> was created without expected data property 'currentScore'");
		if (!('sectionsList' in this._state)) console.warn("<App> was created without expected data property 'sectionsList'");
		if (!('urlParams' in this._state)) console.warn("<App> was created without expected data property 'urlParams'");
		if (!('selectQuiz' in this._state)) console.warn("<App> was created without expected data property 'selectQuiz'");
		if (!('quizList' in this._state)) console.warn("<App> was created without expected data property 'quizList'");
		if (!('layerID' in this._state)) console.warn("<App> was created without expected data property 'layerID'");
		if (!('layerGame' in this._state)) console.warn("<App> was created without expected data property 'layerGame'");
		if (!('score' in this._state)) console.warn("<App> was created without expected data property 'score'");
		if (!('questions' in this._state)) console.warn("<App> was created without expected data property 'questions'");
		if (!('question' in this._state)) console.warn("<App> was created without expected data property 'question'");
		if (!('point' in this._state)) console.warn("<App> was created without expected data property 'point'");
		if (!('calc' in this._state)) console.warn("<App> was created without expected data property 'calc'");
		if (!('emotion' in this._state)) console.warn("<App> was created without expected data property 'emotion'");
		if (!('emotions' in this._state)) console.warn("<App> was created without expected data property 'emotions'");
		if (!('resultQuestion' in this._state)) console.warn("<App> was created without expected data property 'resultQuestion'");
		if (!('reBuildQuestions' in this._state)) console.warn("<App> was created without expected data property 'reBuildQuestions'");
		this._intro = !!options.intro;

		this._handlers.state = [onstate$1];

		onstate$1.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment$1(this, this._state);

		this.root._oncreate.push(() => {
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(App.prototype, protoDev);
	assign(App.prototype, methods$1);

	App.prototype._checkReadOnly = function _checkReadOnly(newState) {
		if ('currentItog' in newState && !this._updatingReadonlyProperty) throw new Error("<App>: Cannot set read-only property 'currentItog'");
		if ('isSectionsEmpty' in newState && !this._updatingReadonlyProperty) throw new Error("<App>: Cannot set read-only property 'isSectionsEmpty'");
	};

	App.prototype._recompute = function _recompute(changed, state) {
		if (changed.currentScore) {
			if (this._differs(state.currentItog, (state.currentItog = currentItog(state)))) changed.currentItog = true;
		}

		if (changed.sectionsList) {
			if (this._differs(state.isSectionsEmpty, (state.isSectionsEmpty = isSectionsEmpty(state)))) changed.isSectionsEmpty = true;
		}
	};

	var  pars = (() => {
		var  p = {};
		location.search.substr(1).split('&').forEach((it) => {
			var  arr = it.split('=');
			p[arr[0]] = arr[1];
		});
		return p;
	})();

	var app = new App({
		target: document.body,
		//target: document.getElementsByClassName('editor-sidebarContainer')[0] || document.body,
		data: {
			urlParams: pars,
			name: 'world'
		}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
